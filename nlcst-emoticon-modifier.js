(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.nlcstEmoticonModifier = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports={
  "emoticons": [
    ">=-[",
    ">=-(",
    ">=[",
    ">=(",
    ">:-[",
    ">:-(",
    ">:[",
    ">:(",
    "=-\"D",
    "=-\"]",
    "=-\")",
    "=\"D",
    "=\"]",
    "=\")",
    ":-\"D",
    ":-\"]",
    ":-\")",
    ":\"D",
    ":\"]",
    ":\")",
    "</3",
    "<\\3",
    "=-\\",
    "=-/",
    "=\\",
    "=/",
    ":-\\",
    ":-/",
    ":\\",
    ":/",
    "='-|",
    "='-[",
    "='-(",
    "='|",
    "='[",
    "='(",
    "=,-|",
    "=,-[",
    "=,-(",
    "=,|",
    "=,[",
    "=,(",
    ":'-|",
    ":'-[",
    ":'-(",
    ":'|",
    ":'[",
    ":'(",
    ":,-|",
    ":,-[",
    ":,-(",
    ":,|",
    ":,[",
    ":,(",
    "=-[",
    "=-(",
    "=[",
    "=(",
    ":-[",
    ":-(",
    ":[",
    ":(",
    "<3",
    "]=-[",
    "]=-(",
    "]=[",
    "]=(",
    "]:-[",
    "]:-(",
    "]:[",
    "]:(",
    "0=-D",
    "0=-]",
    "0=-)",
    "0=D",
    "0=]",
    "0=)",
    "0:-D",
    "0:-]",
    "0:-)",
    "0:D",
    "0:]",
    "0:)",
    "O=-D",
    "O=-]",
    "O=-)",
    "O=D",
    "O=]",
    "O=)",
    "O:-D",
    "O:-]",
    "O:-)",
    "O:D",
    "O:]",
    "O:)",
    "o=-D",
    "o=-]",
    "o=-)",
    "o=D",
    "o=]",
    "o=)",
    "o:-D",
    "o:-]",
    "o:-)",
    "o:D",
    "o:]",
    "o:)",
    "='-D",
    "='-]",
    "='-)",
    "='D",
    "=']",
    "=')",
    "=,-D",
    "=,-]",
    "=,-)",
    "=,D",
    "=,]",
    "=,)",
    ":'-D",
    ":'-]",
    ":'-)",
    ":'D",
    ":']",
    ":')",
    ":,-D",
    ":,-]",
    ":,-)",
    ":,D",
    ":,]",
    ":,)",
    "=-*",
    "=*",
    ":-*",
    ":*",
    "X-D",
    "X-]",
    "X-)",
    "X]",
    "X)",
    "x-D",
    "x-]",
    "x-)",
    "xD",
    "x]",
    "x)",
    "X-3",
    "X3",
    "x-3",
    "x3",
    ";-3",
    ";3",
    "=-3",
    "=3",
    ":-3",
    ":3",
    "=-|",
    "=|",
    ":-|",
    ":|",
    ":-",
    "=-0",
    "=-O",
    "=-o",
    "=0",
    "=O",
    "=o",
    ":-0",
    ":-O",
    ":-o",
    ":0",
    ":O",
    ":o",
    "=-@",
    "=@",
    ":-@",
    ":@",
    "=-D",
    "=D",
    ":-D",
    ":D",
    "=-]",
    "=-)",
    "=]",
    "=)",
    ":-]",
    ":-)",
    ":]",
    ":)",
    "]=-D",
    "]=-]",
    "]=-)",
    "]=D",
    "]=]",
    "]=)",
    "]:-D",
    "]:-]",
    "]:-)",
    "]:D",
    "]:]",
    "]:)",
    "=',-[",
    "=',-(",
    "=',[",
    "=',(",
    "=,'-[",
    "=,'-(",
    "=,'[",
    "=,'(",
    ":',-[",
    ":',-(",
    ":',[",
    ":',(",
    ":,'-[",
    ":,'-(",
    ":,'[",
    ":,'(",
    "=-d",
    "=-P",
    "=-p",
    "=d",
    "=P",
    "=p",
    ":-d",
    ":-P",
    ":-p",
    ":d",
    ":P",
    ":p",
    "X-d",
    "X-P",
    "X-p",
    "Xd",
    "Xp",
    "x-d",
    "x-P",
    "x-p",
    "xP",
    ";-d",
    ";-P",
    ";-p",
    ";d",
    ";P",
    ";p",
    "B-D",
    "B-]",
    "B-)",
    "B]",
    "B)",
    "8-D",
    "8-]",
    "8-)",
    "8D",
    "8]",
    "8)",
    "'=-[",
    "'=-(",
    "'=[",
    "'=(",
    "':-[",
    "':-(",
    "':[",
    "':(",
    ",=-[",
    ",=-(",
    ",=[",
    ",=(",
    ",:-[",
    ",:-(",
    ",:[",
    ",:(",
    "'=-D",
    "'=-]",
    "'=-)",
    "'=D",
    "'=]",
    "'=)",
    "':-D",
    "':-]",
    "':-)",
    "':D",
    "':]",
    "':)",
    ",=-D",
    ",=-]",
    ",=-)",
    ",=D",
    ",=]",
    ",=)",
    ",:-D",
    ",:-]",
    ",:-)",
    ",:D",
    ",:]",
    ",:)",
    "=-Z",
    "=-S",
    "=-z",
    "=-s",
    "=-$",
    "=Z",
    "=S",
    "=z",
    "=s",
    "=$",
    ":-Z",
    ":-S",
    ":-z",
    ":-s",
    ":-$",
    ":Z",
    ":S",
    ":z",
    ":s",
    ":$",
    ";-D",
    ";-]",
    ";-)",
    ";D",
    ";]",
    ";)"
  ],
  "start": [
    ">",
    "=",
    ":",
    "<",
    "]",
    "0",
    "O",
    "o",
    "X",
    "x",
    ";",
    "B",
    "8",
    "'",
    ","
  ],
  "end": [
    "[",
    "(",
    "D",
    "]",
    ")",
    "3",
    "\\",
    "/",
    "|",
    "*",
    "-",
    "0",
    "O",
    "o",
    "@",
    "d",
    "P",
    "p",
    "Z",
    "S",
    "z",
    "s",
    "$"
  ]
}

},{}],2:[function(require,module,exports){
/**
 * @author Titus Wormer
 * @copyright 2014-2015 Titus Wormer
 * @license MIT
 * @module nlcst:emoticon-modifier
 * @fileoverview Emoticons in NLCST.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var toString = require('nlcst-to-string');
var modifier = require('unist-util-modify-children');
var information = require('./data/emoticon.json');

/*
 * Constants: node types.
 */

var EMOTICON_NODE = 'EmoticonNode';

/*
 * Constants: magic numbers.
 *
 * Emoticons are treated by a parser as multiple nodes.
 * Because this modifier walks forwards, when a non-
 * emoticon matches it would normaly walk to the end
 * (the last node). However, because the longest emoticon
 * is tokenized as `Punctuation` (eyes), `Punctuation`
 * (a tear), `Punctuation` (another tear), `Punctuation`
 * (a nose), and `Punctuation` (a frowning mouth), we can
 * safely break when the modifier has walked 5 characters.
 */

var MAX_EMOTICON_LENGTH = 5;

/*
 * Constants for emoticons.
 */

var emoticons = information.emoticons;
var start = new RegExp(information.start.join('|'));
var end = information.end;

/**
 * Merge emoticons into an `EmoticonNode`.
 *
 * @param {CSTNode} child - Node to check.
 * @param {number} index - Position of `child` in `parent`.
 * @param {CSTNode} parent - Parent of `node`.
 * @return {number?} - Either void, or the next index to
 *   iterate over.
 */
function mergeEmoticons(child, index, parent) {
    var siblings;
    var value;
    var siblingIndex;
    var node;
    var emoticon;
    var subvalue;

    /*
     * Check if `child`s first character could be used
     * to start an emoticon.
     */

    if (start.test(toString(child).charAt(0))) {
        siblings = parent.children;
        siblingIndex = index;
        node = child;
        value = '';

        while (node) {
            if (value.length >= MAX_EMOTICON_LENGTH) {
                return;
            }

            subvalue = toString(node);

            value += subvalue;

            /*
             * The second test, if the last character of
             * the current node is superfluous but
             * improves performance by 30%.
             */

            if (
                node.type !== EMOTICON_NODE &&
                end.indexOf(subvalue.charAt(subvalue.length - 1)) !== -1 &&
                emoticons.indexOf(value) !== -1
            ) {
                emoticon = {
                    'type': EMOTICON_NODE,
                    'value': value
                };

                if (child.position && node.position) {
                    emoticon.position = {
                        'start': child.position.start,
                        'end': node.position.end
                    }
                }

                siblings.splice(index, siblingIndex - index + 1, emoticon);

                /*
                 * Some emoticons, like `:-`, can be followed by
                 * more characters to form other emoticons.
                 */

                return index - 1;
            }

            node = siblings[++siblingIndex];
        }
    }
}

/*
 * Expose.
 */

module.exports = modifier(mergeEmoticons);

},{"./data/emoticon.json":1,"nlcst-to-string":3,"unist-util-modify-children":4}],3:[function(require,module,exports){
/**
 * @author Titus Wormer
 * @copyright 2014-2015 Titus Wormer
 * @license MIT
 * @module nlcst:to-string
 * @fileoverview Transform an NLCST node into a string.
 */

'use strict';

/* eslint-env commonjs */

/**
 * Stringify an NLCST node.
 *
 * @param {NLCSTNode|Array.<NLCSTNode>} node - Node to to
 *   stringify.
 * @return {string} - Stringified `node`.
 */
function nlcstToString(node) {
    var values;
    var length;
    var children;

    if (typeof node.value === 'string') {
        return node.value;
    }

    children = 'length' in node ? node : node.children;
    length = children.length;

    /*
     * Shortcut: This is pretty common, and a small performance win.
     */

    if (length === 1 && 'value' in children[0]) {
        return children[0].value;
    }

    values = [];

    while (length--) {
        values[length] = nlcstToString(children[length]);
    }

    return values.join('');
}

/*
 * Expose.
 */

module.exports = nlcstToString;

},{}],4:[function(require,module,exports){
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module unist:util:modify-children
 * @fileoverview Unist utility to modify direct children of a parent.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var iterate = require('array-iterate');

/**
 * Modifier for children of `parent`.
 *
 * @typedef modifyChildren~callback
 * @param {Node} child - Current iteration;
 * @param {number} index - Position of `child` in `parent`;
 * @param {Node} parent - Parent node of `child`.
 * @return {number?} - Next position to iterate.
 */

/**
 * Function invoking a bound `fn` for each child of `parent`.
 *
 * @typedef modifyChildren~modifier
 * @param {Node} parent - Node with children.
 * @throws {Error} - When not given a parent node.
 */

/**
 * Pass the context as the third argument to `callback`.
 *
 * @param {modifyChildren~callback} callback - Function to wrap.
 * @return {function(Node, number): number?} - Intermediate
 *   version partially aplied version of
 *   `modifyChildren~modifier`.
 */
function wrapperFactory(callback) {
    return function (value, index) {
        return callback(value, index, this);
    };
}

/**
 * Turns `callback` into a ``iterator'' accepting a parent.
 *
 * see ``array-iterate'' for more info.
 *
 * @param {modifyChildren~callback} callback - Function to wrap.
 * @return {modifyChildren~modifier}
 */
function iteratorFactory(callback) {
    return function (parent) {
        var children = parent && parent.children;

        if (!children) {
            throw new Error('Missing children in `parent` for `modifier`');
        }

        return iterate(children, callback, parent);
    };
}

/**
 * Turns `callback` into a child-modifier accepting a parent.
 *
 * See `array-iterate` for more info.
 *
 * @param {modifyChildren~callback} callback - Function to wrap.
 * @return {modifyChildren~modifier} - Wrapped `fn`.
 */
function modifierFactory(callback) {
    return iteratorFactory(wrapperFactory(callback));
}

/*
 * Expose.
 */

module.exports = modifierFactory;

},{"array-iterate":5}],5:[function(require,module,exports){
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module array-iterate
 * @fileoverview `forEach` with the possibility to change the next position.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Methods.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Callback given to `iterate`.
 *
 * @callback iterate~callback
 * @this {*} - `context`, when given to `iterate`.
 * @param {*} value - Current iteration.
 * @param {number} index - Position of `value` in `values`.
 * @param {{length: number}} values - Currently iterated over.
 * @return {number?} - Position to go to next.
 */

/**
 * `Array#forEach()` with the possibility to change
 * the next position.
 *
 * @param {{length: number}} values - Values.
 * @param {arrayIterate~callback} callback - Callback given to `iterate`.
 * @param {*?} [context] - Context object to use when invoking `callback`.
 */
function iterate(values, callback, context) {
    var index = -1;
    var result;

    if (!values) {
        throw new Error(
            'TypeError: Iterate requires that |this| ' +
            'not be ' + values
        );
    }

    if (!has.call(values, 'length')) {
        throw new Error(
            'TypeError: Iterate requires that |this| ' +
            'has a `length`'
        );
    }

    if (typeof callback !== 'function') {
        throw new Error(
            'TypeError: callback must be a function'
        );
    }

    /*
     * The length might change, so we do not cache it.
     */

    while (++index < values.length) {
        /*
         * Skip missing values.
         */

        if (!(index in values)) {
            continue;
        }

        result = callback.call(context, values[index], index, values);

        /*
         * If `callback` returns a `number`, move `index` over to
         * `number`.
         */

        if (typeof result === 'number') {
            /*
             * Make sure that negative numbers do not
             * break the loop.
             */

            if (result < 0) {
                index = 0;
            }

            index = result - 1;
        }
    }
}

/*
 * Expose.
 */

module.exports = iterate;

},{}]},{},[2])(2)
});